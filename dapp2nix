#!/usr/bin/env bash
set -eo pipefail
shopt -s lastpipe

export GIT_CONFIG_NOSYSTEM=1
unset XDG_CONFIG_HOME
unset HOME

usage() {
  echo >&2 "
Usage: dapp2nix COMMAND [ARGS]

Commands

  init                      Create a .dapp.json
  migrate                   Populate .dapp.json from submodules
  add <URL> [REF]           Add a dependency from URL pointing to a Git repo
  remove | rm <NAME>        Remove a dependency
  update | up [NAME [REF]]  Update a dependency to REF
  list | ls                 List dependencies
  help                      Print this message
"
}

export getSpec='rev=$(git rev-parse HEAD); \
fullref=$(git for-each-ref --contains $rev | sed -n "s/^.*refs\/\(heads\|remotes\/\)//p" | sort -k1.1,1.1 -rs | head -n1); \
remote=${fullref%/*}; remote=${remote:-origin};
ref=${fullref#*/}; \
url=$(git remote get-url $remote | sed "s/\(\.git\|\/\)$//"); \
alias=${url##*/}; con=${alias}_${rev::7}; '

submods() {
  git submodule --quiet foreach --recursive \
    "$getSpec"'printf %s\\n "$PWD $con"' \
    | sort -k2 -u
}
export -f submods

subdeps() {
  git submodule --quiet foreach "$getSpec"'printf %s "
        \"$alias\": \"$con\","'
}
export -f subdeps

spec() {
  (cd "$1"
    eval "$getSpec"
    deps=$(subdeps)
    name=$alias-${rev::7}
    printf %s "
    \"$con\": {
      \"name\": \"$alias\",
      \"deps\": {${deps%,}
      },
      \"repo\": {
        \"name\": \"$name\",
        \"url\": \"$url\",
        \"rev\": \"$rev\",
        \"ref\": \"${ref#refs/remotes/*/}\"
      }
    }"
  )
}
export -f spec

specs() {
  eval "$getSpec"

  local repos; repos="$1
$PWD $con"
  local root; root=$(realpath .)
  local deps;
  local sep; sep=""

  printf %s "{
  \"contracts\": {"

  echo >&2 "$repos"
  for path in $(cut -d " " -f1 <<<"$repos"); do

    if [[ $path != "$root" ]]; then
      printf %s "$sep"; sep=","
      if [[ -f "$path/.dapp.json" ]]; then
        jq .contracts "$path/.dapp.json" | sed '1d;$d'
      else
        spec "$path"
      fi
    fi
  done

  #deps=$(subdeps)
  printf %s "
  },
  \"this\": {
$(spec "$path" | sed '1,2d;$d')
  }
}"
}
export -f specs

main() {
  local repos; repos=$(submods)

  [ -n "$repos" ] || { echo >&2 'Submodules not initiated? Run: `git submodule update --init --recursive`'; exit 1; }

  specs "$repos"
}
export -f main

tmpclone() {
  local target; target=$(mktemp -d "dapp2nix_git_XXXXXX")
  git clone "$1" "$target" >&2
  (cd "$target" || exit 3
    git checkout "${2:-HEAD}" >&2 || exit 3
    if [[ -f "./dapp.json" ]]; then
      cat ./dapp.json
    else
      git submodule update --init --recursive >&2 || exit 3
      main "$target"
    fi
  ) || exit $?
  rm -rf "$target"
}

clean_deps() {
  echo "Not implemented" >&2
  echo "$1"
}

add_dep() {
  local jsonIn="$1"
  local ref=${3:-HEAD}
  local specs=$(tmpclone "$2" "$ref") || exit $?
  local contracts=$(jq .contracts <<<"$specs")
  local this=$(jq .this <<<"$specs")
  local addname=$(jq -r '.name' <<<"$this")
  local addrev=$(jq -r '.repo.rev' <<<"$this")
  local addcon="${addname}_${addrev::7}"

  [[ $(jq ".this.deps.\"$addname\"" <<<"$jsonIn") == null ]] || {
    echo >&2 "Dependency $addname already exists, not adding. Use \`dapp2nix update $addname $ref\` instead."
    exit 1
  }

  jq "{contracts:([.contracts, $contracts, {\"$addcon\":$this}] | add), this:([.this, {deps:([.this.deps, {\"$addname\":\"$addcon\"}] | add)}] | add)}" <<<"$jsonIn"
}

init() {
    printf %s "
{
  \"contracts\": {},
  \"this\": {
$(spec "$path" | sed '1,2d;$d')
  }
}"
}

remove_dep() {
  local jsonOut=$(jq "del(.this.deps.\"$2\")" <<<"$1")
  clean_deps "$jsonOut"
}

update_dep() {
  local con=$(jq ".this.deps.\"$2\"" <<<"$1")

  [[ $con != null ]] || {
    echo >&2 "Dependency $2 not added. Use \`dapp2nix add\` first"
    exit 1
  }

  local dep=$(jq ".contracts.$con" <<<"$1")
  local ref=${3:-$(jq -r ".repo.ref" <<<"$dep")}
  local url=$(jq -r ".repo.url" <<<"$dep")
  local jsonOut
  jsonOut=$(remove_dep "$1" "$2")
  jsonOut=$(clean_deps "$jsonOut")
  add_dep "$jsonOut" "$url" "$ref"
}

update_deps() {
  {
    list_deps "$1" | cut -d " " -f1 | while read -r dep; do
      update_dep "$1" "$dep"
    done
  } | merge_json
}

list_deps() {
  jq -r '
    .contracts as $cs
    | .this.deps | to_entries | .[]
    | ($cs[.value] as $c
      | $c.name + " " + $c.repo.ref + " " + $c.repo.rev
      )
  ' <<<"$1"
}

merge_json() {
  jq -s 'reduce .[] as $x ({}; . * $x)'
}

save() {
  jq -S '.version = ($ENV.DAPP2NIX_FORMAT_VERSION | tonumber)' <<<"$1" > "$2"
}

outPath="$PWD/.dapp.json"
outDir="$PWD"

[[ -f "$outPath" || $1 == init ]] || {
  echo >&2 "Couldn't read .dapp.json, please run: \`dapp2nix init\` first"
  exit 1
}

case "${1:-help}" in
  init)
    save "$(init)" "$outPath"
    cp "${DAPP2NIX_EXPR-dapp2.nix}" "$outDir/dapp2.nix"
    chmod +w "$outDir/dapp2.nix"
    ;;
  add)
    jsonOut=$(add_dep "$(cat "$outPath")" "$2" "$3") || exit $?
    save "$jsonOut" "$outPath"
    ;;
  remove|rm)
    jsonOut=$(remove_dep "$(cat "$outPath")" "$2") || exit $?
    save "$jsonOut" "$outPath"
    ;;
  list|ls)
    list_deps "$(cat "$outPath")"
    ;;
  update|up)
    if [[ -n $2 ]]; then
      jsonOut=$(update_dep "$(cat "$outPath")" "$2" "$3") || exit $?
    else
      jsonOut=$(update_deps "$(cat "$outPath")") || exit $?
    fi
    save "$jsonOut" "$outPath"
    ;;
  migrate)
    save "$(main)" "$outPath"
    ;;
  help)
    usage
    ;;
  *)
    echo >&2 "No command $1"
    usage
    exit 1
    ;;
esac
